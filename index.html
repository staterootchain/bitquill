<!DOCTYPE html>
<!--
    BitQuill - Secure Rich Text Editor
    Copyright (C) 2024 Nick @Ciphernom on X

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

    Contact information:
    Nick @Ciphernom on X
    Nick btconometrics@protonmail.com

    Project repository:
    https://github.com/staterootchain/bitquill/
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BitQuill - Secure Rich Text Editor</title>
    <!-- Include Quill stylesheet from CDN -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <style>
        /* Basic Styling for Layout and Components */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1000px;
            margin: auto;
            background-color: #fff;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        h1, h2 {
            text-align: center;
        }
        #editor-container {
            height: 300px;
        }
        .section {
            margin-top: 30px;
        }
        .buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
        }
        #status.success {
            background-color: #d4edda;
            color: #155724;
        }
        #status.error {
            background-color: #f8d7da;
            color: #721c24;
        }
        #status.info {
            background-color: #cce5ff;
            color: #004085;
        }
        #document-hash, #content-display, #serialized-data {
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 5px;
            word-break: break-all;
        }
        #proofs-list {
            list-style-type: none;
            padding: 0;
        }
        #proofs-list li {
            background-color: #f1f3f5;
            margin-bottom: 5px;
            padding: 10px;
            border-radius: 4px;
        }
        /* Spinner Styling */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s linear infinite;
            display: none;
            margin-left: 10px;
            vertical-align: middle;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>BitQuill - Secure Rich Text Editor</h1>

        <!-- Editor Section -->
        <div class="section">
            <h2>Editor</h2>
            <div id="editor-container"></div>
            <div class="buttons">                
                <button id="new-doc-btn">New Document</button>
                <button id="verify-btn" disabled>Verify Document</button>
                <button id="serialize-btn">Serialize Document</button>
                <button id="deserialize-btn">Deserialize Document</button>
                <button id="timestamp-btn">Manual Timestamp</button>
                <input type="file" id="file-input" accept=".json" style="display: none;">
            </div>
            <div class="spinner" id="spinner" aria-hidden="true"></div>
        </div>

        <!-- Status Display Section -->
        <div class="section">
            <h2>Status</h2>
            <div id="status" class="info">Ready to start editing...</div>
        </div>

        <!-- Document Hash Display Section -->
        <div class="section">
            <h2>Current Document Hash</h2>
            <div id="document-hash">No hash yet...</div>
        </div>

        <!-- Document Content Display Section -->
        <div class="section">
            <h2>Document Content</h2>
            <div id="content-display">No content yet...</div>
        </div>

        <!-- Serialized Data Display Section -->
        <div class="section">
            <h2>Serialized Document Data</h2>
            <pre id="serialized-data">No serialized data yet...</pre>
        </div>

        <!-- Proofs Display Section -->
        <div class="section">
            <h2>Proofs</h2>
            <ul id="proofs-list"></ul>
        </div>
    </div>

    <!-- OpenTimestamps library -->
    <script src="https://opentimestamps.org/assets/javascripts/vendor/opentimestamps.min.js"></script>
    
    <!-- Include Quill library from CDN -->
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>

    <!-- Main Application Script -->
    <script>

    /**
     * BitQuill Application
     * A secure rich text editor with blockchain-like integrity and OpenTimestamps integration
     * 
     * Features:
     * - Rich text editing using Quill
     * - Hash chain for document integrity
     * - Proof of Work for each edit
     * - Asynchronous OpenTimestamps integration
     * - Document serialization and deserialization
     * - Document verification
     */
    class BitQuillApp {
        constructor() {
            // UI Elements
            this.editorContainer = document.getElementById('editor-container');
            this.newDocBtn = document.getElementById('new-doc-btn');
            this.verifyBtn = document.getElementById('verify-btn');
            this.serializeBtn = document.getElementById('serialize-btn');
            this.deserializeBtn = document.getElementById('deserialize-btn');
            this.timestampBtn = document.getElementById('timestamp-btn');
            this.fileInput = document.getElementById('file-input');
            this.statusDisplay = document.getElementById('status');
            this.spinner = document.getElementById('spinner');
            this.documentHashDisplay = document.getElementById('document-hash');
            this.contentDisplay = document.getElementById('content-display');
            this.serializedDataDisplay = document.getElementById('serialized-data');
            this.proofsList = document.getElementById('proofs-list');

            // Document State
            this.quill = null;
            this.hashChain = []; // Array to store hash chain entries
            this.currentHash = ''; // Latest hash in the hash chain
            this.difficulty = 1; // Initial difficulty level for PoW (adjustable)
            this.editCount = 0; // Number of edits since last difficulty adjustment
            this.totalCharacters = 0; // Total characters in the current batch of edits
            this.totalTime = 0; // Total PoW time in milliseconds for the current batch

            // PoW Task Queue
            this.powQueue = []; // Queue for PoW tasks
            this.isProcessingPoW = false; // Flag for tracking if PoW is being processed

            // Initialize Web Worker for PoW
            this.initializeWebWorker();
                // Check if required libraries are loaded
            if (typeof Quill === 'undefined') {
                console.error('Quill library is not loaded.');
                this.updateStatus('Quill library is not loaded. Editor functionality is unavailable.', 'error');
            }
            if (typeof OpenTimestamps === 'undefined') {
                console.error('OpenTimestamps library is not loaded.');
                this.updateStatus('OpenTimestamps library is not loaded. Timestamping is unavailable.', 'error');
            }
        }

        /**
         * Initialize the application
         */
        init() {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    this.initializeQuillEditor();
                    this.attachEventListeners();
                    this.initializeGenesisEntry();
                });
            } else {
                this.initializeQuillEditor();
                this.attachEventListeners();
                this.initializeGenesisEntry();
            }
        }

        /**
         * Initialize the Quill Rich Text Editor
         */
        initializeQuillEditor() {
            console.log('Initializing Quill editor...');
            try {
                this.quill = new Quill(this.editorContainer, {
                    theme: 'snow',
                    modules: {
                        toolbar: [
                            [{ header: [1, 2, 3, false] }],
                            ['bold', 'italic', 'underline'],
                            ['link', 'image'],
                            [{ list: 'ordered' }, { list: 'bullet' }],
                            ['clean']
                        ]
                    }
                });

                console.log('Quill editor initialized successfully');

                // Listen to text changes in the editor
                this.quill.on('text-change', (delta, oldDelta, source) => {
                    if (source === 'user') {
                        this.handleEdit(delta);
                    }
                });
            } catch (error) {
                console.error('Error initializing Quill editor:', error);
                this.updateStatus('Failed to initialize the editor. Please check the console for more information.', 'error');
            }
        }


        /**
         * Attach event listeners to UI buttons
         */
        attachEventListeners() {
            this.newDocBtn.addEventListener('click', () => this.newDocument());
            this.verifyBtn.addEventListener('click', () => this.verifyDocument());
            this.serializeBtn.addEventListener('click', () => this.serializeDocument());
            this.deserializeBtn.addEventListener('click', () => this.fileInput.click());
            this.timestampBtn.addEventListener('click', () => this.manualTimestamp());
            this.fileInput.addEventListener('change', (event) => this.deserializeDocument(event));
        }

        /**
         * Initialize the genesis entry in the hash chain
         */
        async initializeGenesisEntry() {
            try {
                console.log('Starting initializeGenesisEntry');
                const genesisContent = this.quill.root.innerHTML;
                console.log('Genesis content:', genesisContent);

                if (!genesisContent) {
                    throw new Error('Genesis content is empty');
                }
                
                const genesisContentHash = await this.computeHash(genesisContent);
                console.log('Genesis content hash:', genesisContentHash);


                // Use a single timestamp for consistency
                const timestamp = Date.now();
                console.log('Timestamp:', timestamp);

                const genesisEntryData = `0${genesisContentHash}${timestamp}`;
                console.log('Genesis entry data:', genesisEntryData);

                // Start Proof of Work for genesis entry
                const powStartTime = performance.now();
                const { nonce, hash } = await this.performProofOfWork(genesisEntryData, this.difficulty);
                const powEndTime = performance.now();
                const powDuration = powEndTime - powStartTime;

                console.log('PoW completed. Nonce:', nonce, 'Hash:', hash, 'Duration:', powDuration);

                // Update tracking variables
                this.totalTime += powDuration;
                const charCount = this.countCharacters(genesisContent);
                this.totalCharacters += charCount;
                this.editCount += 1;

                // Create genesis entry
                const genesisEntry = {
                    prev_hash: '0', // No previous hash for genesis
                    content_hash: genesisContentHash,
                    current_hash: hash,
                    nonce: nonce,
                    timestamp: timestamp,
                    difficulty: this.difficulty,
                    totalTime: this.totalTime,
                    totalCharacters: this.totalCharacters,
                    editCount: this.editCount,
                    openTimestamp: null // Will be updated asynchronously
                };

                console.log('Genesis entry created:', genesisEntry);

                // Append to hash chain and update current hash
                this.hashChain.push(genesisEntry);
                this.currentHash = genesisEntry.current_hash;

                // Trigger asynchronous timestamping for genesis entry
                await this.createAsyncTimestamp(genesisContentHash, 0);

                // Update UI elements
                this.updateUIAfterEdit('Initialized with genesis entry.', 'info');
                this.updateHashDisplay();
                this.updateProofsDisplay();
                this.updateContentDisplay();

                // Enable the Verify button now that genesis is initialized
                this.verifyBtn.disabled = false;

                console.log('initializeGenesisEntry completed successfully');
            } catch (error) {
                console.error('Detailed error in initializeGenesisEntry:', error);
                this.updateStatus(`Genesis Entry initialization failed: ${error.message}`, 'error');
            }
        }

        /**
         * Handle user edits in the Quill editor
         * @param {Object} delta - The delta object representing the change
         */
        async handleEdit(delta) {
            // Get the current content as HTML
            const currentContent = this.quill.root.innerHTML;
            const contentHash = await this.computeHash(currentContent);

            // Prepare data for hashing: previous_hash + content_hash + timestamp
            const timestamp = Date.now();
            const dataToHash = `${this.currentHash}${contentHash}${timestamp}`;

            // Check if we need to create an OpenTimestamps proof (as per difficulty, every 100 edits)
            const needsTimestamp = this.editCount % 100 === 0;

            // Enqueue PoW task
            this.enqueuePoWTask({
                dataToHash: dataToHash,
                currentContent: currentContent,
                contentHash: contentHash,
                timestamp: timestamp,
                needsTimestamp: needsTimestamp
            });
        }

        /**
         * Enqueue a PoW task and start processing if not already active
         * @param {Object} task - The PoW task to enqueue
         */
        enqueuePoWTask(task) {
            this.powQueue.push(task);

            // Start processing if not currently doing PoW
            if (!this.isProcessingPoW) {
                this.processNextPoWTask();
            }
        }

        /**
         * Create a new document, resetting the editor and hash chain
         */
        newDocument() {
            // Clear the editor
            this.quill.setText('');

            // Reset the hash chain and other state variables
            this.hashChain = [];
            this.currentHash = '';
            this.difficulty = 1;
            this.editCount = 0;
            this.totalCharacters = 0;
            this.totalTime = 0;

            // Reinitialize the genesis entry
            this.initializeGenesisEntry();

            // Update UI
            this.updateUIAfterEdit('New document created.', 'success');
            this.updateHashDisplay();
            this.updateProofsDisplay();
            this.updateContentDisplay();
        }


        /**
         * Process the next task in the PoW queue
         */
        async processNextPoWTask() {
            if (this.powQueue.length === 0) {
                this.isProcessingPoW = false;
                return;
            }

            this.isProcessingPoW = true;

            // Get the next task from the queue
            const task = this.powQueue.shift();
            const { dataToHash, currentContent, contentHash, timestamp, needsTimestamp } = task;

            // Show processing status and spinner
            this.updateStatus('Processing edit...', 'info');
            this.spinner.style.display = 'inline-block';

            try {
                // Start Proof of Work
                const powStartTime = performance.now();
                const { nonce, hash } = await this.performProofOfWork(dataToHash, this.difficulty);
                const powEndTime = performance.now();
                const powDuration = powEndTime - powStartTime;

                // Update tracking variables
                this.totalTime += powDuration;
                this.totalCharacters = this.countCharacters(currentContent);
                this.editCount += 1;

                // Find the last timestamped entry
                const lastTimestampedEntry = this.hashChain.slice().reverse().find(entry => entry.openTimestamp !== null);

                // Create a new hash chain entry
                const newEntry = {
                    prev_hash: this.currentHash,
                    content_hash: contentHash,
                    current_hash: hash,
                    nonce: nonce,
                    timestamp: timestamp,
                    difficulty: this.difficulty,
                    totalTime: this.totalTime,
                    totalCharacters: this.totalCharacters,
                    editCount: this.editCount,
                    openTimestamp: null,  // Will be updated if a new timestamp is created
                    lastTimestampIndex: lastTimestampedEntry ? this.hashChain.indexOf(lastTimestampedEntry) : null
                };

                // Append the new entry to the hash chain
                this.hashChain.push(newEntry);
                const newEntryIndex = this.hashChain.length - 1;
                this.currentHash = hash;

                // Trigger asynchronous timestamping if needed
                if (needsTimestamp) {
                    this.createAsyncTimestamp(contentHash, newEntryIndex);
                }

                // After every 100 edits, adjust difficulty
                if (this.editCount % 100 === 0) {
                    this.adjustDifficulty();
                }

                // Update UI elements
                this.updateUIAfterEdit('Edit processed and added to hash chain.', 'success');
                this.updateHashDisplay();
                this.updateProofsDisplay();
                this.updateContentDisplay();

            } catch (error) {
                console.error('Error during PoW processing:', error);
                this.updateStatus(`Error processing edit: ${error.message}`, 'error');
            } finally {
                // Hide spinner
                this.spinner.style.display = 'none';

                // Process the next task in the queue
                this.processNextPoWTask();
            }
        }

        /**
         * Initialize a Web Worker for Proof of Work (PoW)
         */
        initializeWebWorker() {
            // Define the worker script as a string
            const workerScript = `
                self.addEventListener('message', async (event) => {
                    const { type, input, difficulty } = event.data;
                    if (type === 'POW') {
                        let nonce = 0;
                        let hash = '';
                        const target = '0'.repeat(difficulty);

                        while (true) {
                            const combined = \`\${input}\${nonce}\`;
                            const encoder = new TextEncoder();
                            const data = encoder.encode(combined);
                            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                            const hashArray = Array.from(new Uint8Array(hashBuffer));
                            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                            if (hashHex.startsWith(target)) {
                                self.postMessage({ type: 'POW_RESULT', nonce: nonce, hash: hashHex });
                                break;
                            }

                            nonce++;

                            // Periodically yield to keep the worker responsive
                            if (nonce % 1000 === 0) {
                                await new Promise(resolve => setTimeout(resolve, 0));
                            }

                            // Prevent infinite loop
                            if (nonce === Number.MAX_SAFE_INTEGER) {
                                self.postMessage({ type: 'POW_ERROR', message: 'Proof of Work failed: Maximum nonce reached.' });
                                break;
                            }
                        }
                    }
                });
            `;

            // Create a Blob from the worker script
            const blob = new Blob([workerScript], { type: 'application/javascript' });
            const workerURL = URL.createObjectURL(blob);
            this.worker = new Worker(workerURL);

            // Listen for messages from the worker
            this.worker.addEventListener('message', (event) => {
                const { type, nonce, hash, message } = event.data;
                if (type === 'POW_RESULT') {
                    if (this.powResolve) {
                        this.powResolve({ nonce, hash });
                        this.powResolve = null;
                        this.powReject = null;
                    }
                } else if (type === 'POW_ERROR') {
                    if (this.powReject) {
                        this.powReject(new Error(message));
                        this.powResolve = null;
                        this.powReject = null;
                    }
                }
            });
        }

        /**
         * Perform Proof of Work using Web Worker
         * @param {String} data - The data to hash
         * @param {Number} difficulty - The difficulty level (number of leading zeros)
         * @returns {Promise} - Resolves with nonce and hash
         */
        performProofOfWork(data, difficulty) {
            return new Promise((resolve, reject) => {
                this.powResolve = resolve;
                this.powReject = reject;
                this.worker.postMessage({ type: 'POW', input: data, difficulty: difficulty });
            });
        }

        /**
         * Compute SHA-256 hash of the given data
         * @param {String} data - The data to hash
         * @returns {String} - Hexadecimal representation of the hash
         */
        async computeHash(data) {
            console.log('computeHash called with data:', data);
            
            if (typeof window === 'undefined' || !window.crypto) {
                throw new Error('Web Crypto API is not available in this environment');
            }
            
            if (!window.crypto.subtle) {
                throw new Error('Crypto.subtle is not available. This might be due to an insecure context.');
            }
            
            try {
                const encoder = new TextEncoder();
                const dataBuffer = encoder.encode(data);
                const hashBuffer = await window.crypto.subtle.digest('SHA-256', dataBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                console.log('Computed hash:', hashHex);
                return hashHex;
            } catch (error) {
                console.error('Error in computeHash:', error);
                throw error;
            }
        }

        /**
         * Convert ArrayBuffer to Hex String
         * @param {ArrayBuffer} buffer - The buffer to convert
         * @returns {String} - Hexadecimal string
         */
        arrayBufferToHex(buffer) {
            const byteArray = new Uint8Array(buffer);
            const hexCodes = Array.from(byteArray).map(value => {
                const hex = value.toString(16);
                return hex.padStart(2, '0');
            });
            return hexCodes.join('');
        }

        /**
         * Count the number of characters in the current document
         * @param {String} content - The HTML content of the document
         * @returns {Number} - Total number of characters (excluding HTML tags)
         */
        countCharacters(content) {
            // Create a temporary DOM element to strip HTML tags
            const tempElement = document.createElement('div');
            tempElement.innerHTML = content;
            const plainText = tempElement.textContent || tempElement.innerText || '';
            return plainText.length;
        }

        /**
         * Adjust the PoW difficulty based on average time per character
         */
        adjustDifficulty() {
            if ( this.editCount % 100 === 0) return; // Only adjust after 10 edits

            if (this.totalCharacters === 0) {
                console.warn('No characters edited. Difficulty remains unchanged.');
                return;
            }

            const averageTimePerChar = this.totalTime / this.totalCharacters; // in ms

            if (averageTimePerChar < 500) {
                this.difficulty += 1;
                this.updateStatus(`Increasing difficulty to ${this.difficulty} for faster PoW.`, 'info');
            } else {
                if (this.difficulty > 1) {
                    this.difficulty -= 1;
                    this.updateStatus(`Decreasing difficulty to ${this.difficulty} for slower PoW.`, 'info');
                } else {
                    this.updateStatus(`Difficulty remains at minimum level ${this.difficulty}.`, 'info');
                }
            }

        }

        /**
         * Create an OpenTimestamp asynchronously
         * @param {String} contentHash - The hash to timestamp
         * @param {Number} entryIndex - The index of the hash chain entry to update
         */
        async createAsyncTimestamp(contentHash, entryIndex) {
            if (typeof OpenTimestamps === 'undefined') {
                console.error('OpenTimestamps library is not available.');
                this.updateStatus('OpenTimestamps is not available. Timestamp not created.', 'error');
                return;
            }

            try {
                const digest = OpenTimestamps.Utils.hexToBytes(contentHash);
                const detachedTimestamp = OpenTimestamps.DetachedTimestampFile.fromHash(new OpenTimestamps.Ops.OpSHA256(), digest);
                
                await OpenTimestamps.stamp(detachedTimestamp);
                
                const serializedTimestamp = detachedTimestamp.serializeToBytes();
                const base64Ots = btoa(String.fromCharCode.apply(null, serializedTimestamp));

                // Update the hash chain entry with the timestamp
                if (this.hashChain[entryIndex]) {
                    this.hashChain[entryIndex].openTimestamp = base64Ots;
                    this.updateProofsDisplay();
                    console.log(`Timestamp created for entry ${entryIndex}`);
                }
            } catch (error) {
                console.error('Error creating OpenTimestamp:', error);
                this.updateStatus(`Failed to create timestamp: ${error.message}`, 'error');
            }
        }

        /**
         * Manually trigger a timestamp for the current document state
         */
        async manualTimestamp() {
            const currentContent = this.quill.root.innerHTML;
            const contentHash = await this.computeHash(currentContent);
            const entryIndex = this.hashChain.length - 1;
            
            this.updateStatus('Creating manual timestamp...', 'info');
            await this.createAsyncTimestamp(contentHash, entryIndex);
            this.updateStatus('Manual timestamp created successfully.', 'success');
        }

        /**
         * Serialize the document along with the hash chain and content hash
         */
        async serializeDocument() {
            // Disable UI to prevent concurrent operations
            this.disableUI();

            // Show serialization status and spinner
            this.updateStatus('Serializing document...', 'info');
            this.spinner.style.display = 'inline-block';

            try {
                // Get the current HTML content
                const currentContent = this.quill.root.innerHTML;
                const contentHash = await this.computeHash(currentContent);

                // Serialize content and hash chain
                const serializedContent = JSON.stringify({
                    content: currentContent,
                    hash_chain: this.hashChain
                }, null, 2);

                // Compute hash of the serialized content
                const contentHashSerialized = await this.computeHash(serializedContent);

                // Create a final serialized object including the content hash
                const finalSerialized = JSON.stringify({
                    content: currentContent,
                    hash_chain: this.hashChain,
                    content_hash: contentHashSerialized
                }, null, 2);

                // Display serialized data
                this.serializedDataDisplay.textContent = finalSerialized;

                // Trigger download of serialized data
                this.downloadSerializedFile(finalSerialized, 'bitquill_document.json');

                // Update status
                this.updateStatus('Document serialized successfully.', 'success');

            } catch (error) {
                console.error('Serialization Error:', error);
                this.updateStatus(`Serialization failed: ${error.message}`, 'error');
            } finally {
                // Re-enable UI
                this.spinner.style.display = 'none';
                this.enableUI();
            }
        }

        /**
         * Trigger download of serialized data as a JSON file
         * @param {String} data - The serialized JSON data
         * @param {String} filename - The desired filename
         */
        downloadSerializedFile(data, filename) {
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        /**
         * Deserialize the document from a JSON file
         * @param {Event} event - The file input change event
         */
        async deserializeDocument(event) {
            const file = event.target.files[0];
            if (!file) {
                this.updateStatus('No file selected for deserialization.', 'error');
                return;
            }

            // Disable UI during deserialization
            this.disableUI();
            this.updateStatus('Deserializing document...', 'info');
            this.spinner.style.display = 'inline-block';

            const reader = new FileReader();

            reader.onload = async (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (!data.content || !data.hash_chain || !data.content_hash) {
                        throw new Error('Invalid serialized data format.');
                    }

                    // Verify the hash of the serialized content
                    const serializedContent = JSON.stringify({
                        content: data.content,
                        hash_chain: data.hash_chain
                    }, null, 2);
                    const computedContentHash = await this.computeHash(serializedContent);
                    if (computedContentHash !== data.content_hash) {
                        throw new Error('Content hash mismatch. Document may be altered.');
                    }

                    // Verify the hash chain integrity
                    const isValid = await this.verifyHashChain(data.hash_chain, data.content);
                    if (!isValid) {
                        throw new Error('Hash chain verification failed. Document may be tampered.');
                    }

                    // Apply the content to Quill editor silently to prevent triggering events
                    this.quill.setContents(this.quill.clipboard.convert(data.content), 'silent');

                    // Restore the hash chain and current hash
                    this.hashChain = data.hash_chain;
                    this.currentHash = this.hashChain[this.hashChain.length - 1].current_hash;

                    // Reset difficulty and tracking variables
                    this.difficulty = this.hashChain[this.hashChain.length - 1].difficulty;
                    this.editCount = this.hashChain[this.hashChain.length - 1].editCount;
                    this.totalCharacters = this.hashChain[this.hashChain.length - 1].totalCharacters;
                    this.totalTime = this.hashChain[this.hashChain.length - 1].totalTime;

                    // Update UI elements
                    this.updateUIAfterEdit('Document deserialized and verified successfully.', 'success');
                    this.updateHashDisplay();
                    this.updateProofsDisplay();
                    this.updateContentDisplay();

                    // Enable the Verify button as the document is now loaded
                    this.verifyBtn.disabled = false;

                } catch (error) {
                    console.error('Deserialization Error:', error);
                    this.updateStatus(`Deserialization failed: ${error.message}`, 'error');
                }

                // Re-enable UI
                this.spinner.style.display = 'none';
                this.enableUI();

                // Reset file input for future deserializations
                this.fileInput.value = '';
            };

            reader.onerror = () => {
                console.error('File reading error.');
                this.updateStatus('Failed to read the file.', 'error');
                this.spinner.style.display = 'none';
                this.enableUI();
            };

            // Read the selected file as text
            reader.readAsText(file);
        }

        /**
         * Verify the integrity of the hash chain
         * @param {Array} hashChain - The array of hash chain entries
         * @param {String} currentContent - The current HTML content from Quill editor
         * @returns {Boolean} - True if valid, else false
         */
        async verifyHashChain(hashChain, currentContent) {
            console.log('Starting hash chain verification...');
            console.log('Hash Chain:', hashChain);

            // Check if hashChain is a valid non-empty array
            if (!Array.isArray(hashChain) || hashChain.length === 0) {
                console.error('Hash chain is empty or not an array.');
                return false;
            }

            // Iterate through each hash chain entry to verify integrity
            for (let i = 0; i < hashChain.length; i++) {
                const entry = hashChain[i];
                console.log(`Verifying entry ${i}:`, entry);

                // Check if entry is defined
                if (!entry) {
                    console.error(`Entry at index ${i} is undefined.`);
                    return false;
                }

                // Check if required properties exist
                const requiredProps = ['prev_hash', 'content_hash', 'current_hash', 'nonce', 'timestamp', 'difficulty', 'totalTime', 'totalCharacters', 'editCount'];
                for (const prop of requiredProps) {
                    if (!entry.hasOwnProperty(prop)) {
                        console.error(`Missing property '${prop}' in entry ${i}.`);
                        return false;
                    }
                }

                // Reconstruct data to hash: previous_hash + content_hash + timestamp
                const prevHash = entry.prev_hash;
                const contentHash = entry.content_hash;
                const timestamp = entry.timestamp;
                const nonce = entry.nonce;

                const dataToHash = `${prevHash}${contentHash}${timestamp}${nonce}`;
                const recomputedHash = await this.computeHash(dataToHash);

                // Verify the recomputed hash matches the stored current_hash
                if (recomputedHash !== entry.current_hash) {
                    console.error(`Hash mismatch at entry ${i}. Expected ${entry.current_hash}, got ${recomputedHash}.`);
                    return false;
                }

                // Verify that the hash satisfies the difficulty requirement
                if (!entry.current_hash.startsWith('0'.repeat(entry.difficulty))) {
                    console.error(`Proof of Work not satisfied at entry ${i}.`);
                    return false;
                }

                // For entries beyond the genesis, ensure prev_hash matches the previous entry's current_hash
                if (i > 0) {
                    const previousEntry = hashChain[i - 1];
                    if (entry.prev_hash !== previousEntry.current_hash) {
                        console.error(`Previous hash mismatch at entry ${i}. Expected ${previousEntry.current_hash}, got ${entry.prev_hash}.`);
                        return false;
                    }
                } else {
                    // For genesis entry, prev_hash should be '0'
                    if (entry.prev_hash !== '0') {
                        console.error(`Genesis entry's previous_hash should be '0', got '${entry.prev_hash}'.`);
                        return false;
                    }
                }
            }

            // Verify that the latest content_hash matches the current document's hash
            const latestEntry = hashChain[hashChain.length - 1];
            const latestContentHash = await this.computeHash(currentContent);
            if (latestContentHash !== latestEntry.content_hash) {
                console.error(`Latest content hash mismatch. Expected ${latestEntry.content_hash}, got ${latestContentHash}.`);
                return false;
            }

            console.log('Hash chain verification successful.');
            return true;
        }

        /**
         * Verify the document's integrity by checking the hash chain and OpenTimestamps
         */
        async verifyDocument() {
            // Disable UI during verification
            this.disableUI();
            this.updateStatus('Verifying document...', 'info');
            this.spinner.style.display = 'inline-block';

            try {
                const currentContent = this.quill.root.innerHTML;
                const isValid = await this.verifyHashChain(this.hashChain, currentContent);
                
                if (isValid) {
                    let confirmedTimestamps = [];
                    let pendingTimestamps = 0;
                    let totalTimestamps = 0;

                    for (let entry of this.hashChain) {
                        if (entry.openTimestamp) {
                            totalTimestamps++;
                            const ots = Uint8Array.from(atob(entry.openTimestamp), c => c.charCodeAt(0));
                            const detachedOts = OpenTimestamps.DetachedTimestampFile.deserialize(ots);
                            const digest = OpenTimestamps.Utils.hexToBytes(entry.content_hash);
                            const detached = OpenTimestamps.DetachedTimestampFile.fromHash(new OpenTimestamps.Ops.OpSHA256(), digest);
                            
                            const verificationResult = await OpenTimestamps.verify(detachedOts, detached);
                            
                            if (verificationResult === undefined) {
                                pendingTimestamps++;
                            } else {
                                // Convert Unix timestamp to milliseconds
                                confirmedTimestamps.push(new Date(verificationResult * 1000));
                            }
                        }
                    }

                    if (confirmedTimestamps.length > 0) {
                        const earliestTimestamp = new Date(Math.min(...confirmedTimestamps));
                        const latestTimestamp = new Date(Math.max(...confirmedTimestamps));
                        this.updateStatus(`Document is valid. Earliest confirmed timestamp: ${earliestTimestamp.toUTCString()}. Latest confirmed timestamp: ${latestTimestamp.toUTCString()}. Confirmed: ${confirmedTimestamps.length}, Pending: ${pendingTimestamps}, Total: ${totalTimestamps}.`, 'success');
                    } else if (pendingTimestamps > 0) {
                        this.updateStatus(`Document is valid. All timestamps (${pendingTimestamps}) are still pending confirmation. Please try again later.`, 'info');
                    } else if (totalTimestamps > 0) {
                        this.updateStatus(`Document is valid. ${totalTimestamps} timestamp(s) created but not yet confirmed. Please try again later.`, 'info');
                    } else {
                        this.updateStatus('Document is valid. No timestamps have been created yet.', 'info');
                    }
                } else {
                    this.updateStatus('Document verification failed. Integrity compromised.', 'error');
                }
            } catch (error) {
                console.error('Verification Error:', error);
                this.updateStatus(`Verification failed: ${error.message}`, 'error');
            }

            // Re-enable UI
            this.spinner.style.display = 'none';
            this.enableUI();
        }


        /**
         * Update UI elements after an edit
         * @param {String} message - Status message
         * @param {String} type - Status type ('success', 'error', 'info')
         */
        updateUIAfterEdit(message, type) {
            this.updateStatus(message, type);
        }

        /**
         * Update the status display
         * @param {String} message - Status message
         * @param {String} type - Status type ('success', 'error', 'info')
         */
        updateStatus(message, type) {
            this.statusDisplay.textContent = message;
            this.statusDisplay.className = `status ${type}`;
        }

        /**
         * Update the document hash display
         */
        updateHashDisplay() {
            this.documentHashDisplay.textContent = this.currentHash;
        }

        /**
         * Update the proofs list display
         */
        updateProofsDisplay() {
            this.proofsList.innerHTML = '';
            this.hashChain.forEach((entry, index) => {
                const listItem = document.createElement('li');
                const date = new Date(entry.timestamp);
                const formattedDate = `${date.toLocaleDateString()} ${date.toLocaleTimeString()}.${date.getMilliseconds()}`;
                
                let timestampStatus = 'Not timestamped';
                if (entry.openTimestamp === null && entry.editCount % 100 === 0) {
                    timestampStatus = 'Timestamp creation in progress...';
                } else if (entry.openTimestamp) {
                    timestampStatus = 'Timestamped';
                } else if (entry.lastTimestampIndex !== null) {
                    timestampStatus = `Refers to timestamp at entry ${entry.lastTimestampIndex}`;
                }

                listItem.textContent = `Entry ${index}: 
                    Prev Hash=${entry.prev_hash.substr(0, 8)}..., 
                    Content Hash=${entry.content_hash.substr(0, 8)}..., 
                    Current Hash=${entry.current_hash.substr(0, 8)}..., 
                    Nonce=${entry.nonce}, 
                    Timestamp=${formattedDate}, 
                    Difficulty=${entry.difficulty},
                    Edit Count=${entry.editCount},
                    OpenTimestamps: ${timestampStatus}`;
                this.proofsList.appendChild(listItem);
            });
        }

        /**
         * Update the document content display
         */
        updateContentDisplay() {
            const textContent = this.quill.getText();
            this.contentDisplay.textContent = textContent.trim() || 'No content yet...';
        }

        /**
         * Disable UI buttons during processing
         */
        disableUI() {
            this.verifyBtn.disabled = true;
            this.serializeBtn.disabled = true;
            this.deserializeBtn.disabled = true;
            this.timestampBtn.disabled = true;
        }

        /**
         * Enable UI buttons after processing
         */
        enableUI() {
            this.verifyBtn.disabled = false;
            this.serializeBtn.disabled = false;
            this.deserializeBtn.disabled = false;
            this.timestampBtn.disabled = false;
        }
    }

// Initialize the BitQuill application once the DOM is fully loaded
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM fully loaded, initializing BitQuillApp...');
    try {
        const app = new BitQuillApp();
        app.init();
        console.log('BitQuillApp initialized successfully');
    } catch (error) {
        console.error('Error initializing BitQuillApp:', error);
        document.getElementById('status').textContent = 'Failed to initialize the application. Please check the console for more information.';
        document.getElementById('status').className = 'status error';
    }
});
</script>

</html>
